#
# Copyright 2010 by Adam Mayer	 <adam@makerbot.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#

#
# HOW TO USE THIS BUILD SCRIPT
#
# By default, this script will build the firmware for an atmega644p-based motherboard.
# The firmware will be built, but not uploaded.
#
# To build for another platform, pass an explicit platform parameter.  For example,
# $ scons platform=rrmbv12
# $ scons platform=mcv10
# $ scons platform=mb24
# $ scons platform=mb24-2560
#
# To upload the firmware, specify the "upload" target.  By default, this will use
# /dev/ttyUSB0 as the serial connection.
# $ scons upload
#
# If you want to select a port manually, specify it as a parameter:
# $ scons port=/dev/ttyUSB3 upload
#

import os
import re
from os.path import dirname
# Parameters
platform = ARGUMENTS.get('platform','lpc1768')

mcu='atmega168'
has_queue = 0
has_psu = 0


def parse_version(v):
    if not v:
        return 0
    if v.find(".") != -1:
       parts = v.split(".")
       return (int(parts[0]) * 100) + int(parts[1])
    return int(v)

def get_default_version():
	regex = re.compile(r"const uint16_t firmware_version = ([0-9]+);")
	return parse_version(f.get_contents().strip())

vstr = File('#/current_version.txt').get_contents().strip()

vstr = ARGUMENTS.get('version',vstr)

version = parse_version(vstr)

target_name = "MB-"+platform+"-v"+str(version//100)+"."+str(version%100)

if (platform == 'lpc1768'):
	mcu='cortex-m3'
	has_queue = 1
	has_psu = 1
else:
	print "Platform "+platform+" is not currently supported. Supported platforms are:"
	print "LPC1768: Gen 5 motherboard"
	exit()

srcs = Glob('system/*.c') + Glob('system/*.S') + Glob('lib/include/*.c') + Glob('lib/source/*.c') + Glob('lib_sd/*.c') + Glob('USBCDC/*.c') + Glob('#src/shared/*.cc') + Glob('*.cc')
#srrcs = Glob('system/libnosys_gnu.c')
#srcs_c = Glob('lib_sd/*.c') + Glob('lib/include/*.c') + Glob('lib/source/*.c') + Glob('system/*.c') + Glob('USBCDC/*.c') + Glob('maplelib/*.c')
#srcs_cc = Glob('*.cc')
#srcs_s = Glob('system/*.S')

include_paths = ['#/src/shared', 'lib/include', 'lib/source', 'lib_sd', 'system', 'USBCDC', '#/src/Motherboard']
search_paths = '-I#/src/shared -I/lib/include -I/lib/source -I/lib_sd -I/system -I/USBCDC -I#/src/Motherboard'
#search_paths = '-L#/src/shared -L/lib/include -L/lib/source -L/lib_sd -L/system -L/USBCDC -L#/src/Motherboard'
#include_paths_B = [-B #/src/shared -B lib/include -B lib/source -B system -B USBCDC -B maplelib -B #/src/Motherboard]

if (os.environ.has_key('BUILD_NAME')):
   flags.append('-DBUILD_NAME=' + os.environ['BUILD_NAME'])

#if (os.environ.has_key('CodeSourcery_PATH')):
#	codesourcery_path = os.environ['CodeSourcery_PATH']
#else:
#	codesourcery_path = dirname(os.popen('/C:/Program Files (x86)/CodeSourcery/Sourcery G++ Lite/bin avr-gcc').readlines()[0])
codesourcery_path = 'C:/PROGRA~2/CodeSourcery/SOURCE~1/bin'

OBJECTS = 'startup_LPC17xx.o core_cm3.o system_LPC17xx.o main_LPC17xx.o'
#LSCRIPT = 'C:\msysgit\git\G3Firmware\v3\src\Motherboard\system\ldscript_rom_gnu.ld'
LSCRIPT = 'C:/msysgit/git/G3Firmware/v3/src/Motherboard/system/ldscript_rom_gnu.ld'
#LSCRIPT = '/C/msysgit/git/G3Firmware/v3/src/Motherboard/system/ldscript_rom_gnu.ld'
#LSCRIPT = '/C/msysgit/git/G3Firmware/v3/src/Motherboard/system/make.LPC17xx.gnu'
#LSCRIPT = '/system/ldscript_rom_gnu.ld'
optimization='0'
DEBUG = '-g'
#LISTING = -ahls


hex_name = target_name + '.hex'
bin_name = target_name + '.bin'
elf_name = target_name + '.elf'
map_name = target_name + '.map'

env=Environment(tools=['mingw'],
	CC=codesourcery_path+'/arm-none-eabi-gcc',
#	LINK=codesourcery_path+'/arm-none-eabi-g++',
	CXX=codesourcery_path+'/arm-none-eabi-g++',
	AS=codesourcery_path+'/arm-none-eabi-as',
	AR=codesourcery_path+'/arm-none-eabi-ar',
	LD=codesourcery_path+'/arm-none-eabi-ld',
	OBJCOPY=codesourcery_path+'/arm-none-eabi-objcopy',
	SIZE=codesourcery_path+'/arm-none-eabi-size',
	#  Compiler Options
	CCFLAGS = '-Wall -fno-common -mcpu='+mcu+' -mthumb -O'+optimization+' '+DEBUG+' -D__RAM_MODE__=0 -DVERSION='+str(version),
	CXXFLAGS = '-Wall -fno-common -mcpu='+mcu+' -mthumb -O'+optimization+' '+DEBUG+' -D__RAM_MODE__=0 -DVERSION='+str(version),
#	LDFLAGS = '-mcpu='+mcu+' -mthumb -O'+optimization+' -nostartfiles -Wl,-Map='+target_name+'.map -Wl,-T -Xlinker '+LSCRIPT+'',
	LDFLAGS = '-mcpu='+mcu+' --gc-sections -mthumb -O'+optimization+' -nostartfiles -Wl,-Map='+target_name+'.map -Wl,-T '+LSCRIPT+' -Wl,--allow-multiple-definition',
#	LDFLAGS = '-ARCH=armv7-m -mcpu='+mcu+' -mthumb -O'+optimization+' -nostartfiles -Wl,-Map='+target_name+'.map -Wl,-T '+LSCRIPT+' $LIBPATH -Wl,--allow-multiple-definition',
#	LDFLAGS = '-O'+optimization+' -nostartfiles -b '+mcu+' -o '+elf_name+' -Map '+map_name+' -T '+LSCRIPT+' --stats --allow-multiple-definition -B #/src/shared -B lib/include -B lib/source -B system -B USBCDC -B maplelib -B #/src/Motherboard',
#	LDFLAGS = '-O'+optimization+' -nostartfiles -Wl,-T -Xlinker '+LSCRIPT+'',
#	-Wl,--allow-multiple-definition',
	ASFLAGS = '-mcpu='+mcu+' --defsym RAM_MODE=0',
	LIBPATH=search_paths,
	CPPPATH=include_paths)

objs = env.Object(srcs)
#env['LINKFLAGS']+=' -T ldscript_rom_gnu.ld '

# run_alias = Alias('run', [program], program[0].path)
# AlwaysBuild(run_alias)

#env.Program(target_name, objs)

# env['target_name']   = '.elf'

#elf = env.Program("elf_name", include_paths)

#program = env.Program('#build/${target_name}.elf', objs, 
#    LINKSCRIPT = File('$LSCRIPT'))
#env.Depends(program, '$LSCRIPT')

env.Append(BUILDERS={'Elf':Builder(action=codesourcery_path+"/arm-none-eabi-g++ -o $TARGET $OBJECTS $SOURCES $LDFLAGS")})
#env.Append(BUILDERS={'Elf':Builder(action=codesourcery_path+"/arm-none-eabi-g++ -o $TARGET $SOURCES $LDFLAGS")})
env.Append(BUILDERS={'Hex':Builder(action=codesourcery_path+"/arm-none-eabi-objcopy -O ihex $SOURCES $TARGET")})
#env.Append(BUILDERS={'Hex':Builder(action=codesourcery_path+"/arm-none-eabi-objcopy -O ihex -R .eeprom $SOURCES $TARGET")})
env.Append(BUILDERS={'Bin':Builder(action=codesourcery_path+"/arm-none-eabi-objcopy -O binary $SOURCES $TARGET")})

#env.Append(BUILDERS={'Elf':Builder(action=avr_tools_path+"/avr-gcc -mmcu="+mcu+" -Os -Wl,--gc-sections -Wl,-Map,"+map_name+" -o $TARGET $SOURCES")})
#env.Append(BUILDERS={'Hex':Builder(action=avr_tools_path+"/avr-objcopy -O ihex -R .eeprom $SOURCES $TARGET")})

#	$(OBJCOPY) -O binary -j .text -j .data $(PROJECT).elf $(PROJECT).bin
	
#	env['PROGSUFFIX']   = '.elf'

#objcopy -O <output-format> <in-file> <out-file>
#arm-none-eabi-objcopy -O binary add.elf add.bin

env.Elf(elf_name, objs) 
env.Hex(hex_name, elf_name)
env.Bin(bin_name, elf_name) 

# env.Alias instead of just Alias because of
# http://scons.tigris.org/issues/show_bug.cgi?id=2443
#upload_alias = env.Alias('upload', hex_name, avrdude_command)
#AlwaysBuild(upload_alias)
